# Калькулятор на Golang

Этот проект реализует калькулятор, который поддерживает арифметические выражения с 
односимвольными идентификаторами и операциями `+`, `-`, `*`, `/` с учетом приоритета 
операторов и скобок. Основной функцией является `Calc`, которая принимает строку с 
выражением, преобразует его в обратную польскую нотацию (RPN), а затем вычисляет результат.

Этот проект я делаю на курсе Яндекс.Лицея "Программирование на Go | 24".

## Описание

Калькулятор поддерживает:
- Арифметические операции `+`, `-`, `*`, `/`.
- Скобки для приоритезации выражений.
- Проверку на ошибки в выражениях, такие как некорректная последовательность операторов и операндов или отсутствие операндов для операций.

Основные этапы работы:
1. Преобразование входного выражения в обратную польскую нотацию.
2. Вычисление результата из выражения в RPN.

### Алгоритм преобразования в обратную польскую нотацию (RPN)

Алгоритм преобразования в RPN используется для упрощения вычислений выражения за счет постфиксной записи операторов, что позволяет избежать необходимости учитывать приоритет операций.

1. **Создание очереди вывода и стека операторов**:
   - Для вывода создается очередь, а для операторов — стек.

2. **Проход по токенам выражения**:
   - **Если токен — число**: добавляем его в очередь вывода.
   - **Если токен — оператор** (`+`, `-`, `*`, `/`): 
     - Удаляем операторы из стека в очередь вывода, пока они имеют больший или равный приоритет.
     - Затем добавляем текущий оператор в стек.
   - **Если токен — открывающая скобка** `(`: добавляем его в стек операторов.
   - **Если токен — закрывающая скобка** `)`: 
     - Удаляем операторы из стека в очередь вывода до тех пор, пока не встретится открывающая скобка `(`, которая затем удаляется из стека.

3. **Очистка стека**:
   - Все оставшиеся операторы из стека перемещаются в очередь вывода.

Алгоритм завершен, и очередь вывода теперь содержит выражение в RPN.

### Алгоритм вычисления результата из выражения в RPN

Алгоритм вычисления выражения в RPN используется для упрощения обработки операторов и соблюдения приоритета.

1. **Создаем стек для вычислений**:
   - Каждый операнд (число) помещается в стек.

2. **Проход по каждому элементу в RPN**:
   - **Если элемент — операнд (число)**: добавляем его в стек.
   - **Если элемент — оператор** (`+`, `-`, `*`, `/`): 
     - Извлекаем два верхних числа из стека.
     - Применяем оператор к этим числам в нужном порядке.
     - Помещаем результат обратно в стек.

3. **Результат**:
   - В конце выполнения стека остается одно значение, которое и есть результат выражения.


## Функция `Calc`

Функция `Calc` является основной точкой входа в калькулятор и состоит из следующих этапов:

1. **Токенизация**: 
   - Функция принимает входное выражение в виде строки и разбивает его на токены (числа, операторы и скобки) для дальнейшего анализа.

2. **Преобразование в RPN**:
   - Токены передаются в функцию преобразования, которая переводит их в обратную польскую нотацию (RPN), используя алгоритм сортировочной станции. Этот этап преобразует инфиксное выражение (с обычным порядком операций) в постфиксное выражение (RPN), что упрощает дальнейшее вычисление.

3. **Вычисление RPN**:
   - Функция обрабатывает постфиксное выражение, используя стек. Она проходит по каждому токену RPN: если это число, оно помещается в стек; если это оператор, из стека извлекаются операнды, к которым применяется оператор, и результат возвращается в стек.
   
4. **Результат или ошибка**:
   - В конце вычислений в стеке должно остаться одно значение, которое является результатом выражения. Если выражение некорректно (например, последовательность операторов или операндов нарушена), функция возвращает соответствующую ошибку.

Пример использования:

```go
result, err := Calc("3 + 5 * ( 2 - 8 )")
if err != nil {
    fmt.Println("Ошибка:", err)
} else {
    fmt.Println("Результат:", result)
}
```

